const INTEGRITY_CHECKSUM="82ef9b96d8393b6da34527d1d6e19187",bypassHeaderName="x-msw-bypass",activeClientIds=new Set;async function resolveMasterClient(event){const client=await self.clients.get(event.clientId);if("top-level"===client.frameType)return client;return(await self.clients.matchAll()).filter((client=>"visible"===client.visibilityState)).find((client=>activeClientIds.has(client.id)))}async function handleRequest(event,requestId){const client=await resolveMasterClient(event),response=await getResponse(event,client,requestId);return client&&activeClientIds.has(client.id)&&async function(){const clonedResponse=response.clone();sendToClient(client,{type:"RESPONSE",payload:{requestId:requestId,type:clonedResponse.type,ok:clonedResponse.ok,status:clonedResponse.status,statusText:clonedResponse.statusText,body:null===clonedResponse.body?null:await clonedResponse.text(),headers:serializeHeaders(clonedResponse.headers),redirected:clonedResponse.redirected}})}(),response}async function getResponse(event,client,requestId){const{request:request}=event,requestClone=request.clone(),getOriginalResponse=()=>fetch(requestClone);if(!client)return getOriginalResponse();if(!activeClientIds.has(client.id))return await getOriginalResponse();if("true"===requestClone.headers.get("x-msw-bypass")){const cleanRequestHeaders=serializeHeaders(requestClone.headers);delete cleanRequestHeaders["x-msw-bypass"];const originalRequest=new Request(requestClone,{headers:new Headers(cleanRequestHeaders)});return fetch(originalRequest)}const reqHeaders=serializeHeaders(request.headers),body=await request.text(),clientMessage=await sendToClient(client,{type:"REQUEST",payload:{id:requestId,url:request.url,method:request.method,headers:reqHeaders,cache:request.cache,mode:request.mode,credentials:request.credentials,destination:request.destination,integrity:request.integrity,redirect:request.redirect,referrer:request.referrer,referrerPolicy:request.referrerPolicy,body:body,bodyUsed:request.bodyUsed,keepalive:request.keepalive}});switch(clientMessage.type){case"MOCK_SUCCESS":return delayPromise((()=>respondWithMock(clientMessage)),clientMessage.payload.delay);case"MOCK_NOT_FOUND":return getOriginalResponse();case"NETWORK_ERROR":{const{name:name,message:message}=clientMessage.payload,networkError=new Error(message);throw networkError.name=name,networkError}case"INTERNAL_ERROR":{const parsedBody=JSON.parse(clientMessage.payload.body);return console.error(`[MSW] Request handler function for "%s %s" has thrown the following exception:\n\n${parsedBody.errorType}: ${parsedBody.message}\n(see more detailed error stack trace in the mocked response body)\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error.\nIf you wish to mock an error response, please refer to this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,request.method,request.url),respondWithMock(clientMessage)}}return getOriginalResponse()}function serializeHeaders(headers){const reqHeaders={};return headers.forEach(((value,name)=>{reqHeaders[name]=reqHeaders[name]?[].concat(reqHeaders[name]).concat(value):value})),reqHeaders}function sendToClient(client,message){return new Promise(((resolve,reject)=>{const channel=new MessageChannel;channel.port1.onmessage=event=>{if(event.data&&event.data.error)return reject(event.data.error);resolve(event.data)},client.postMessage(JSON.stringify(message),[channel.port2])}))}function delayPromise(cb,duration){return new Promise((resolve=>{setTimeout((()=>resolve(cb())),duration)}))}function respondWithMock(clientMessage){return new Response(clientMessage.payload.body,{...clientMessage.payload,headers:clientMessage.payload.headers})}function uuidv4(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(function(c){const r=16*Math.random()|0;return("x"==c?r:3&r|8).toString(16)}))}self.addEventListener("install",(function(){return self.skipWaiting()})),self.addEventListener("activate",(async function(event){return self.clients.claim()})),self.addEventListener("message",(async function(event){const clientId=event.source.id;if(!clientId||!self.clients)return;const client=await self.clients.get(clientId);if(!client)return;const allClients=await self.clients.matchAll();switch(event.data){case"KEEPALIVE_REQUEST":sendToClient(client,{type:"KEEPALIVE_RESPONSE"});break;case"INTEGRITY_CHECK_REQUEST":sendToClient(client,{type:"INTEGRITY_CHECK_RESPONSE",payload:INTEGRITY_CHECKSUM});break;case"MOCK_ACTIVATE":activeClientIds.add(clientId),sendToClient(client,{type:"MOCKING_ENABLED",payload:!0});break;case"MOCK_DEACTIVATE":activeClientIds.delete(clientId);break;case"CLIENT_CLOSED":activeClientIds.delete(clientId);0===allClients.filter((client=>client.id!==clientId)).length&&self.registration.unregister();break}})),self.addEventListener("fetch",(function(event){const{request:request}=event;if("navigate"===request.mode)return;if("only-if-cached"===request.cache&&"same-origin"!==request.mode)return;if(0===activeClientIds.size)return;const requestId=uuidv4();return event.respondWith(handleRequest(event,requestId).catch((error=>{console.error('[MSW] Failed to mock a "%s" request to "%s": %s',request.method,request.url,error)})))}));